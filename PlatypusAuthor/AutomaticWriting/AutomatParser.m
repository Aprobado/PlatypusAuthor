//
//  PlatypusParser.m
//  PlatypusAuthor
//
//  Created by Raphael on 27.04.14.
//  Copyright (c) 2014 HEAD. All rights reserved.
//

#import "AutomatParser.h"
#import "AutomatToken.h"
#import "NSPair.h"
#import "Tag.h"

@implementation AutomatParser

NSString* content;

NSString* htmlOpen = @"<!doctype html>\n<html lang=\"fr\">\n<head>\n\t<!--file generated by PlatypusAuthor-->\n\t<meta charset=\"utf-8\" />\n</head>\n";
NSString* htmlClose = @"\n</html>";

+ (NSString *)automatFileToHtml:(NSString *)file {
    NSString *text = [NSString stringWithContentsOfFile:file encoding:NSUTF8StringEncoding error:nil];
    return [AutomatParser automatToHtmlWithString:text];
}

+ (NSString *)automatToHtmlWithString:(NSString *)automatText {
    
    // while there's an opening bracket in the file, find and replace segments that are in between brackets level by level to handle nesting
    while ([automatText rangeOfString:@"{"].location != NSNotFound) {
        
        // get occurences of "{" and "}"
        NSArray *bracketMatches = [AutomatParser getOccurencesOfRegularExpression:@"\\{|\\}" inString:automatText];
        
        NSArray *pairs = [AutomatParser getFirstLevelPairsOfBracketsInBrackets:bracketMatches];
        
        if (pairs == nil) return nil;
        
        // NSLog(@"pairs found: %@", pairs);
        
        NSMutableArray *stringsToSwap = [[NSMutableArray alloc] init];
        
        // first get the pair of strings to swap
        for (NSPair *pair in pairs) {
            NSPair *stringToSwap = [AutomatParser convertedSegment:pair InString:automatText];
            [stringsToSwap addObject:stringToSwap];
        }
        // then replace them
        for (NSPair *stringToSwap in stringsToSwap) {
            automatText = [automatText stringByReplacingOccurrencesOfString:[stringToSwap a] withString:[stringToSwap b]];
        }
    }
    
    //automatText = [automatText stringByReplacingOccurrencesOfString:@"\n" withString:@"<br />\n"];
    
    //content = automatText;
    //content = [content stringByReplacingOccurrencesOfString:@"\n" withString:@"<br />"];
    //[self convertIdentifiers];
    //[self convertClasses];
    //[self ExtractFunctions];
    
    // add doctype and opening and closing html tags
    automatText = [NSString stringWithFormat:@"%@%@%@%@", htmlOpen, automatText, @"\n<style>#titre{font-size:2em;}</style>", htmlClose];
    
    return automatText;
    
}

+ (NSArray *)getOccurencesOfRegularExpression:(NSString *)expression inString:(NSString *)string withRange:(NSRange)range {
    
    NSError *error = NULL;
    NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:expression
                                                                           options:NSRegularExpressionCaseInsensitive
                                                                             error:&error];
    if (error != nil) NSLog(@"%@", error);
    NSMutableArray *matches = [[NSMutableArray alloc] init];
    [regex enumerateMatchesInString:string
                            options:0
                              range:range
                         usingBlock:^(NSTextCheckingResult *result, NSMatchingFlags flags, BOOL *stop) {
                             AutomatToken *token = [[AutomatToken alloc] init];
                             token.range = result.range;
                             token.string = [string substringWithRange:token.range];
                             [matches addObject:token];
                         }];
    
    return [NSArray arrayWithArray:matches];
}

+ (NSArray *)getOccurencesOfRegularExpression:(NSString *)expression inString:(NSString *)string {
    
    return [AutomatParser getOccurencesOfRegularExpression:expression inString:string withRange:NSMakeRange(0, [string length])];
}

+ (NSArray *)getFirstLevelPairsOfBracketsInBrackets:(NSArray *)brackets {
    if ([brackets count] % 2 != 0) {
        NSLog(@"Error: bracket count must be pair, a bracket is missing somewhere");
        return nil;
    }
    NSMutableArray *pairs = [[NSMutableArray alloc] init];
    if ([[brackets objectAtIndex:0] isEqualTo:@"}"]) {
        NSLog(@"Error: First opening bracket is missing");
        return nil;
    }
    
    for (int i = 0; i < [brackets count]; i++) {
        AutomatToken *bracket = [brackets objectAtIndex:i];
        if ([[bracket string] isEqualTo:@"{"]) {
            
            if (i == [brackets count]-1) {
                NSLog(@"Error: Last closing bracket is missing");
            }
            
            AutomatToken *openingBracket = bracket;
            
            // look for its closing part
            NSInteger index = 0;
            for (int j = i+1; j < [brackets count]; j++) {
                
                AutomatToken *bracket = [brackets objectAtIndex:j];
                
                if ([[bracket string] isEqualTo:@"{"]) {
                    // we need to look further
                    index ++;
                } else if ([[bracket string] isEqualTo:@"}"]) {
                    if (index == 0) {
                        // we've found our pair
                        AutomatToken *closingBracket = bracket;
                        [pairs addObject:[[NSPair alloc] initWithA:openingBracket B:closingBracket]];
                        i = j;
                        break;
                    } else {
                        index --;
                    }
                }
                
            }
        }
    }
    
    return [NSArray arrayWithArray:pairs];
}

// a segment here is a portion of text between two tokens
// returns  NSPair.a old segment to replace (automatSegment)
//          NSPair.b converted segment (htmlSegment)
+ (NSPair *)convertedSegment:(NSPair *)tokenPair InString:(NSString *)string {
    AutomatToken *start = (AutomatToken *)[tokenPair a];
    AutomatToken *end = (AutomatToken *)[tokenPair b];
    
    NSString *automatSegment = [string substringWithRange:NSMakeRange(start.range.location, end.range.location-start.range.location+1)];
    
    Tag *tag = [AutomatParser tagOfSegment:start InString:string];
    
    NSString *automatSegmentWithSuffixe = [tag.automatTag stringByAppendingString:automatSegment];
    
    NSString *tagString = @"";
    switch (tag.attribute) {
        case ID:
            tagString = [NSString stringWithFormat:@" id=\"%@\"", tag.name];
            break;
        case CLASS:
            tagString = [NSString stringWithFormat:@" class=\"%@\"", tag.name];
            break;
        case NONE:
            tagString = @"";
            break;
        default:
            break;
    }
    
    // htmlBodySegment is "automatSegment" without the brackets
    NSString *htmlBodySegment = [automatSegment substringWithRange:NSMakeRange(1, automatSegment.length-2)];
    NSString *htmlSegment = [NSString stringWithFormat:@"<%@%@>%@</%@>", tag.type, tagString, htmlBodySegment, tag.type];
    
    return [[NSPair alloc] initWithA:automatSegmentWithSuffixe B:htmlSegment];
}

+ (Tag *)tagOfSegment:(AutomatToken *)segmentStart InString:(NSString *)string {
    Tag *tag = [[Tag alloc] init];
    
    // scan backwards from the opening bracket until a space or a "new line" char (\n) to find the tag
    NSInteger index = 0;
    NSInteger location = segmentStart.range.location;
    NSString *character = [string substringWithRange:segmentStart.range];
    while (![character isEqualTo:@" "] && ![character isEqualTo:@"\n"] && (location-index) >= 0) {
        index ++;
        if ((location-index) < 0) {
            tag.type = @"div";
            break;
        }
        character = [string substringWithRange:NSMakeRange(location-index, 1)];
    }
    
    if ([character isEqualTo:@"\n"]) tag.type = @"div";
    if ([character isEqualTo:@" "]) tag.type = @"span";
    
    // index == 0 if there is no tag before the opening bracket
    if (index == 0) tag.automatTag = @"";
    else tag.automatTag = [string substringWithRange:NSMakeRange(location - (index - 1), index-1)];
    
    if ([tag.automatTag isEqualTo:@""]) {
        tag.attribute = NONE;
        tag.name = @"";
    } else {
        NSString *firstLetter = [tag.automatTag substringWithRange:NSMakeRange(0, 1)];
        if ([firstLetter isEqualTo:@"#"]) tag.attribute = ID;
        else if ([firstLetter isEqualTo:@"."]) tag.attribute = CLASS;
        else tag.attribute = NONE;
        tag.name = [tag.automatTag substringFromIndex:1];
    }
    
    return tag;
}

#pragma mark **** Unused methods ****

+ (void)convertIdentifiers {
    
    NSString* expression = @"(#)(.+?)\\{(.+)(?:\\}<(.*)>)";
    
    NSError *error = NULL;
    NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:expression
                                                                           options:NSRegularExpressionCaseInsensitive
                                                                             error:&error];
    // NSLog(@"regex error: %@", [error localizedDescription]);
    // if we need the  matches count
    /*
    NSUInteger numberOfMatches = [regex numberOfMatchesInString:content
                                                        options:0
                                                          range:NSMakeRange(0, [content length])];
     */
    /*
    NSArray *matches = [regex matchesInString:content
                                      options:0
                                        range:NSMakeRange(0, [content length])];
    
    for (NSTextCheckingResult *match in matches) {
        NSRange matchRange = [match range];
        NSRange firstHalfRange = [match rangeAtIndex:1];
        NSRange secondHalfRange = [match rangeAtIndex:2];
    }
    */
    
    // $1 = "#"
    // $2 = "id"
    // $3 = "text"
    // $4 = function inside <>
    
    NSMutableString *mutableContent = [[NSMutableString alloc] init];
    [mutableContent appendString:content];
    NSUInteger matches = [regex replaceMatchesInString:mutableContent
                                                options:0
                                                  range:NSMakeRange(0, [mutableContent length])
                                           withTemplate:@"<div id=\"$2\" $4>\n$3\n</div>"];
    
    content = [NSString stringWithString:mutableContent];
}

+ (void)convertClasses {
    NSString* expression = @"\\.([^ ]+?)\\{(.+?)\\}";
    
    NSError *error = NULL;
    NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:expression
                                                                           options:NSRegularExpressionCaseInsensitive
                                                                             error:&error];
    // $1 = "class"
    // $2 = "text"
    NSMutableString *mutableContent = [[NSMutableString alloc] init];
    [mutableContent appendString:content];
    NSUInteger matches = [regex replaceMatchesInString:mutableContent
                                               options:0
                                                 range:NSMakeRange(0, [mutableContent length])
                                          withTemplate:@"<div class=\"$1\">$2</class>"];
    NSLog(@"class matches nb: %lu", (unsigned long)matches);
    content = [NSString stringWithString:mutableContent];
}

+ (void)extractFunctions {
    NSString* expression = @"\\w*\\s*\\(.*\\)\\s*\\{\\s*(.*\\s)*\\}";
    
    NSError *error = NULL;
    NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:expression
                                                                           options:NSRegularExpressionCaseInsensitive
                                                                             error:&error];
    NSLog(@"regex error: %@", [error localizedDescription]);
    
    content = [regex stringByReplacingMatchesInString:content
                                                      options:0
                                                        range:NSMakeRange(0, [content length])
                                                 withTemplate:@"<script>\nfunction $0\n</script>"];
}

@end
